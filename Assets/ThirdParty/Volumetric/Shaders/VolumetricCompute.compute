#pragma enable_d3d11_debug_symbols

#pragma kernel SaveHistory
#pragma kernel InitAllVolumes
#pragma kernel WriteMaterialVolumeConstant
#pragma kernel WriteMaterialVolumeConstant _WITH_NOISE
#pragma kernel WriteScatterVolumeDir
#pragma kernel Accumulation
#pragma kernel TemporalBlendShadowVolume
#pragma kernel TemporalBlendMaterialVolume
#pragma kernel TemporalBlendScatterVolume
#pragma kernel TemporalBlendAccumulationVolume

#include "VolumetricHelper.hlsl"

// Kernels
[numthreads(8, 8, 16)]
void SaveHistory(uint3 pos : SV_DispatchThreadID)
{
    _PrevShadowVolume[pos] = _ShadowVolume[pos];
    _PrevMaterialVolume_A[pos] = _MaterialVolume_A[pos];
    _PrevScatterVolume[pos] = _ScatterVolume[pos];
    _PrevAccumulationVolume[pos] = _AccumulationVolume[pos];
}

[numthreads(8, 8, 16)]
void InitAllVolumes(uint3 pos : SV_DispatchThreadID)
{
    _ShadowVolume[pos] = 1;
    _MaterialVolume_A[pos] = 0;
    _MaterialVolume_B[pos] = 0;
    _ScatterVolume[pos] = 0;
    _AccumulationVolume[pos] = float4(0, 0, 0, 1);
}

[numthreads(8, 8, 16)]
void WriteMaterialVolumeConstant(uint3 pos : SV_DispatchThreadID)
{
    _MaterialVolume_A[pos] = float4(_ScatteringCoef, _AbsorptionCoef);
    _MaterialVolume_B[pos] = float4(_PhaseG, 0, 0, 0);

    #ifdef _WITH_NOISE
        float3 jitterFroxelPos = JitterFroxelPos(pos);
        float3 worldPos = FroxelPosToWorldPos(jitterFroxelPos);
        float3 uvw = worldPos * _NoiseTiling + _NoiseScrollingSpeed * _Time.x;
        float noise = _NoiseTex.SampleLevel(sampler_bilinear_repeat, uvw, 0.0).r;
        _MaterialVolume_A[pos] *= noise;
    #endif
}

[numthreads(8, 8, 16)]
void WriteScatterVolumeDir(uint3 pos : SV_DispatchThreadID)
{
    float visibility = _ShadowVolume[pos];

    float4 materialVolumeA = _MaterialVolume_A[pos];
    float4 materialVolumeB = _MaterialVolume_B[pos];

    float3 scatterCoef = materialVolumeA.rgb;
    float absorptCoef = materialVolumeA.a;
    float phaseG = materialVolumeB.r;

    float3 worldPos = FroxelPosToWorldPos(pos);
    float3 viewDir = normalize(worldPos - _WorldSpaceCameraPos);
    float cosTheta = dot(viewDir, -_LightDir);

    visibility = pow(visibility, 10);

    float3 inScatter = visibility * PhaseFunction(phaseG, cosTheta) * _LightColor * scatterCoef;
    float extinction = Rgb2Gray(scatterCoef) + absorptCoef;

    _ScatterVolume[pos] += float4(inScatter, extinction);
}

[numthreads(8, 8, 1)]
void Accumulation(uint2 pos : SV_DispatchThreadID)
{    
    float4 accumulation = float4(0, 0, 0, 1);
    uint3 curPos = uint3(pos.xy, 0);
    uint3 prevPos = uint3(pos.xy, 0);

    for (int i = 1; i <= _VolumeDepth; i++)
    {
        curPos.z = i;
        prevPos.z = i - 1;
        float4 scatterVolume = _ScatterVolume[curPos];
        float3 inScatter = scatterVolume.rgb;
        float extinction = scatterVolume.a;

        float3 curViewPos = FroxelPosToViewPos(curPos).xyz;
        float3 prevViewPos = FroxelPosToViewPos(prevPos).xyz;
        float stepLength = curViewPos.z - prevViewPos.z;

        accumulation = ScatterStep(accumulation.rgb, accumulation.a, inScatter, extinction, stepLength);
        _AccumulationVolume[curPos] = accumulation;
    }
}

[numthreads(8, 8, 16)]
void TemporalBlendShadowVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPosToWorldPos(pos);
    float3 prevFroxelPos = WorldPosToPrevFroxelPos(worldPos);

    float3 prevUvw = FroxelPosToFroxelUvw(prevFroxelPos);
    float prevShadow = _PrevShadowVolumeSrv.SampleLevel(sampler_bilinear_clamp, prevUvw, 0.0);
    
    float reprojSuccess = dot(prevUvw.xy - saturate(prevUvw.xy), 1.0) == 0.0;
    _ShadowVolume[pos] = lerp(_ShadowVolume[pos], prevShadow, _TemporalBlendAlpha * reprojSuccess);
}

[numthreads(8, 8, 16)]
void TemporalBlendMaterialVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPosToWorldPos(pos);
    float3 prevFroxelPos = WorldPosToPrevFroxelPos(worldPos);
    //_MaterialVolume_A[pos] = lerp(_MaterialVolume_A[pos], _PrevMaterialVolume_A[prevFroxelPos], _TemporalBlendAlpha);
}

[numthreads(8, 8, 16)]
void TemporalBlendScatterVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPosToWorldPos(pos);
    float3 prevFroxelPos = WorldPosToPrevFroxelPos(worldPos);
    //_ScatterVolume[pos] = lerp(_ScatterVolume[pos], + _PrevScatterVolume[prevFroxelPos], _TemporalBlendAlpha);
}

[numthreads(8, 8, 16)]
void TemporalBlendAccumulationVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPosToWorldPos(pos);
    float3 prevFroxelPos = WorldPosToPrevFroxelPos(worldPos);

    float3 prevUvw = FroxelPosToFroxelUvw(prevFroxelPos);
    float4 prevAccumulation = _PrevAccumulationVolumeSrv.SampleLevel(sampler_bilinear_clamp, prevUvw, 0.0);

    float reprojSuccess = dot(prevUvw.xy - saturate(prevUvw.xy), 1.0) == 0.0;
    _AccumulationVolume[pos] = lerp(_AccumulationVolume[pos], prevAccumulation, _TemporalBlendAlpha * reprojSuccess);
}