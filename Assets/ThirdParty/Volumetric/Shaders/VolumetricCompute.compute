#pragma enable_d3d11_debug_symbols

#pragma kernel SaveHistory
#pragma kernel InitAllVolumes
#pragma kernel WriteMaterialVolumeConstant
#pragma kernel WriteMaterialVolumeConstant _WITH_NOISE
#pragma kernel WriteScatterVolumeDir
#pragma kernel Accumulation
#pragma kernel TemporalBlendShadowVolume
#pragma kernel TemporalBlendMaterialVolume
#pragma kernel TemporalBlendScatterVolume

#include "VolumetricHelper.hlsl"

// Kernels
[numthreads(8, 8, 16)]
void SaveHistory(uint3 pos : SV_DispatchThreadID)
{
    _PrevShadowVolume[pos] = _ShadowVolume[pos];
    _PrevMaterialVolume_A[pos] = _MaterialVolume_A[pos];
    _PrevScatterVolume[pos] = _ScatterVolume[pos];
    _PrevAccumulationVolume[pos] = _AccumulationVolume[pos];
}

[numthreads(8, 8, 16)]
void InitAllVolumes(uint3 pos : SV_DispatchThreadID)
{
    _ShadowVolume[pos] = 1;
    _MaterialVolume_A[pos] = 0;
    _MaterialVolume_B[pos] = 0;
    _ScatterVolume[pos] = 0;
    _AccumulationVolume[pos] = float4(0, 0, 0, 1);
}

[numthreads(8, 8, 16)]
void WriteMaterialVolumeConstant(uint3 pos : SV_DispatchThreadID)
{
    _MaterialVolume_A[pos] = float4(_ScatteringCoef, _AbsorptionCoef);
    _MaterialVolume_B[pos] = float4(_PhaseG, 0, 0, 0);

    #ifdef _WITH_NOISE
        float3 jitterFroxelPos = JitterFroxelPos(pos);
        float3 worldPos = FroxelPos2WorldPos(jitterFroxelPos);
        float3 uvw = worldPos * _NoiseTiling + _NoiseScrollingSpeed * _Time.x;
        float noise = _NoiseTex.SampleLevel(sampler_bilinear_repeat, uvw, 0).r;
        _MaterialVolume_A[pos] *= noise;
    #endif
}

[numthreads(8, 8, 16)]
void WriteScatterVolumeDir(uint3 pos : SV_DispatchThreadID)
{
    //pos = JitterFroxelPos(pos);

    float visibility = _ShadowVolume[pos];

    float4 materialVolumeA = _MaterialVolume_A[pos];
    float4 materialVolumeB = _MaterialVolume_B[pos];

    float3 scatterCoef = materialVolumeA.rgb;
    float absorptCoef = materialVolumeA.a;
    float phaseG = materialVolumeB.r;

    float3 worldPos = FroxelPos2WorldPos(pos);
    float3 viewDir = normalize(worldPos - _WorldSpaceCameraPos);
    float cosTheta = dot(viewDir, -_LightDir);

    float3 inScatter = visibility * PhaseFunction(phaseG, cosTheta) * _LightColor * scatterCoef;
    float extinction = Rgb2Gray(scatterCoef) + absorptCoef;

    _ScatterVolume[pos] += float4(inScatter, extinction);
}

[numthreads(8, 8, 1)]
void Accumulation(uint2 pos : SV_DispatchThreadID)
{
    uint3 curPos = uint3(pos.xy, _AccumulationSlice);
    uint3 prevPos = uint3(pos.xy, _AccumulationSlice - 1);
    
    float4 accumulationVolume = _AccumulationVolume[prevPos];
    float3 accumuLight = accumulationVolume.rgb;
    float totalTransmittance = accumulationVolume.a;

    float4 materialVolumeA = _MaterialVolume_A[curPos];
    float4 scatterVolume = _ScatterVolume[curPos];
    float3 scatterCoef = materialVolumeA.rgb;
    float3 inScatter = scatterVolume.rgb;
    float extinction = scatterVolume.a;

    float3 curViewPos = FroxelPos2ViewPos(curPos).xyz;
    float3 prevViewPos = FroxelPos2ViewPos(prevPos).xyz;
    float stepLength = curViewPos.z - prevViewPos.z;

    float transmittance = exp(-extinction * stepLength);
    totalTransmittance *= transmittance;
    accumuLight += inScatter * totalTransmittance * stepLength;

    _AccumulationVolume[curPos] = float4(accumuLight, totalTransmittance);
}

[numthreads(8, 8, 16)]
void TemporalBlendShadowVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPos2WorldPos(pos);
    float3 prevFroxelPos = WorldPos2PrevFroxelPos(worldPos);
    _ShadowVolume[pos] = lerp(_ShadowVolume[pos], _PrevShadowVolume[pos], _TemporalBlendAlpha);
}

[numthreads(8, 8, 16)]
void TemporalBlendMaterialVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPos2WorldPos(pos);
    float3 prevFroxelPos = WorldPos2PrevFroxelPos(worldPos);
    //_MaterialVolume_A[pos] = lerp(_MaterialVolume_A[pos], _PrevMaterialVolume_A[prevFroxelPos], _TemporalBlendAlpha);
}

[numthreads(8, 8, 16)]
void TemporalBlendScatterVolume(uint3 pos : SV_DispatchThreadID)
{
    float3 worldPos = FroxelPos2WorldPos(pos);
    float3 prevFroxelPos = WorldPos2PrevFroxelPos(worldPos);
    //_ScatterVolume[pos] = lerp(_ScatterVolume[pos], + _PrevScatterVolume[prevFroxelPos], _TemporalBlendAlpha);
}
