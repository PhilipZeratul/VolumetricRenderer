#pragma enable_d3d11_debug_symbols

#pragma kernel InitAllVolumes
#pragma kernel WriteMaterialVolumeConstant
#pragma kernel WriteScatterVolumeDir
#pragma kernel Accumulation
#pragma kernel TemporalBlendShadowVolume
#pragma kernel TemporalBlendMaterialVolume
#pragma kernel TemporalBlendScatterVolume

#include "VolumetricHelper.hlsl"

// Kernels
[numthreads(8, 8, 8)]
void InitAllVolumes(uint3 pos : SV_DispatchThreadID)
{
    _PrevShadowVolume[pos] = _ShadowVolume[pos];
    _PrevMaterialVolume_A[pos] = _MaterialVolume_A[pos];
    _PrevMaterialVolume_B[pos] = _MaterialVolume_B[pos];
    _PrevScatterVolume[pos] = _ScatterVolume[pos];

    _ShadowVolume[pos] = 1;
    _MaterialVolume_A[pos] = 0;
    _MaterialVolume_B[pos] = 0;
    _ScatterVolume[pos] = 0;
}

[numthreads(8 ,8, 8)]
void WriteMaterialVolumeConstant(uint3 pos : SV_DispatchThreadID)
{
    _MaterialVolume_A[pos] = float4(_ScatteringCoef, _AbsorptionCoef);
    _MaterialVolume_B[pos] = float4(_PhaseG, 0, 0, 0);
}

[numthreads(8, 8, 8)]
void WriteScatterVolumeDir(uint3 pos : SV_DispatchThreadID)
{
    float visibility = _ShadowVolume[pos];

    float4 materialA = _MaterialVolume_A[pos];
    float4 materialB = _MaterialVolume_B[pos];

    float3 scatterCoef = materialA.rgb;
    float absorptCoef = materialA.a;
    float phaseG = materialB.r;

    float3 worldPos = FroxelPos2WorldPos(pos);
    float3 viewDir = normalize(worldPos - _WorldSpaceCameraPos);
    float cosTheta = dot(viewDir, -_LightDir);

    float3 inScatter = visibility * PhaseFunction(phaseG, cosTheta) * _LightColor * scatterCoef;
    float extinction = Rgb2Gray(scatterCoef) + absorptCoef;

    _ScatterVolume[pos] += float4(inScatter, extinction);
}

[numthreads(8, 8, 1)]
void Accumulation(uint2 pos : SV_DispatchThreadID)
{
    float3 accumuLight = 0.0;
    float totalTransmittance = 1.0;
    float alpha = 0.0;

    float2 uv = FroxelPos2Uv(pos);
    float depth = 1 - _CameraDepthTexture.SampleLevel(sampler_bilinear_clamp, uv, 0).r;
    float maxZ = Depth2FroxelPosZ(depth);

    for (int i = 0; i < maxZ; i++)
    {
        uint3 curPos = uint3(pos.xy, i);
        uint3 nextPos = uint3(pos.xy, i + 1);

        float4 materialA = _MaterialVolume_A[curPos];
        float4 scatterVolume = _ScatterVolume[curPos];
        float3 scatterCoef = materialA.rgb;
        float3 inScatter = scatterVolume.rgb;
        float extinction = scatterVolume.a;
        
        // TODO: Simplify stepLength calculaiton?
        float3 curWorldPos = FroxelPos2WorldPos(uint3(curPos)).xyz;
        float3 nextWorldPos = FroxelPos2WorldPos(uint3(nextPos)).xyz;
        float stepLength = distance(nextWorldPos, curWorldPos);

        float transmittance = exp(-extinction * stepLength);
        totalTransmittance *= transmittance;
        accumuLight += inScatter * totalTransmittance * stepLength;
        alpha += (1 - transmittance) * (1 - alpha);
    }

    _AccumulationTex[pos] = float4(accumuLight, alpha);
}

[numthreads(8, 8, 8)]
void TemporalBlendShadowVolume(uint3 pos : SV_DispatchThreadID)
{
    uint3 reprojPos = mul(_ReprojMat, pos);

    _ShadowVolume[pos] = _ShadowVolume[pos] * (1 - _TemporalBlendAlpha) + _PrevShadowVolume[pos] * _TemporalBlendAlpha;
}

[numthreads(8, 8, 8)]
void TemporalBlendMaterialVolume(uint3 pos : SV_DispatchThreadID)
{
    uint3 reprojPos = mul(_ReprojMat, pos);

    _MaterialVolume_A[pos] = _MaterialVolume_A[pos] * (1 - _TemporalBlendAlpha) + _PrevMaterialVolume_A[pos] * _TemporalBlendAlpha;
    _MaterialVolume_B[pos] = _MaterialVolume_B[pos] * (1 - _TemporalBlendAlpha) + _PrevMaterialVolume_B[pos] * _TemporalBlendAlpha;
}

[numthreads(8, 8, 8)]
void TemporalBlendScatterVolume(uint3 pos : SV_DispatchThreadID)
{
    uint3 reprojPos = mul(_ReprojMat, pos);

    _ScatterVolume[pos] = _ScatterVolume[pos] * (1 - _TemporalBlendAlpha) + _PrevScatterVolume[pos] * _TemporalBlendAlpha;
}
