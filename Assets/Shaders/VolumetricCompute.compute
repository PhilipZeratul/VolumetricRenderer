#pragma enable_d3d11_debug_symbols

#pragma kernel ClearAllVolumes
#pragma kernel WriteMaterialVolumeConstant
#pragma kernel WriteScatterVolumeDir
#pragma kernel Accumulation

#include "VolumetricHelper.hlsl"

// Kernels
[numthreads(8, 8, 8)]
void ClearAllVolumes(uint3 pos : SV_DispatchThreadID)
{
    _ShadowVolume[pos] = 1;
    _MaterialVolume_A[pos] = 0;
    _MaterialVolume_B[pos] = 0;
    _ScatterVolume[pos] = 0;
    _AccumulationTex[pos.xy] = 0;
}

[numthreads(8 ,8, 8)]
void WriteMaterialVolumeConstant(uint3 pos : SV_DispatchThreadID)
{
    _MaterialVolume_A[pos] = float4(_ScatteringCoef, _AbsorptionCoef);
    _MaterialVolume_B[pos] = float4(_PhaseG, 0, 0, 0);
}

[numthreads(8, 8, 8)]
void WriteScatterVolumeDir(uint3 pos : SV_DispatchThreadID)
{
    // TODO: Sample shadow.
    float visibility = _ShadowVolume[pos];

    float4 materialA = _MaterialVolume_A[pos];
    float4 materialB = _MaterialVolume_B[pos];

    float3 scatterCoef = materialA.rgb;
    float absorptCoef = materialA.a;
    float phaseG = materialB.r;

    float cosTheta = dot(_ViewDir, -_LightDir);

    float3 inScatter = visibility * PhaseFunction(phaseG, cosTheta) * _LightColor * scatterCoef;
    float extinction = Rgb2Gray(scatterCoef) + absorptCoef;

    _ScatterVolume[pos] += float4(inScatter, extinction);
}

[numthreads(8, 8, 1)]
void Accumulation(uint2 pos : SV_DispatchThreadID)
{
    float3 accumuLight = 0.0;
    float transmittance = 1.0;

    for (int i = 0; i < _VolumeDepth - 1; i++)
    {
        uint3 curPos = uint3(pos.xy, i);
        uint3 nextPos = uint3(pos.xy, i + 1);

        float4 materialA = _MaterialVolume_A[curPos];
        float4 scatterVolume = _ScatterVolume[curPos];
        float3 scatterCoef = materialA.rgb;
        float3 inScatter = scatterVolume.rgb;
        float extinction = scatterVolume.a;
        
        // TODO: Simplify stepLength calculaiton?
        float3 curWorldPos = FroxelPos2WorldPos(uint3(curPos)).xyz;
        float3 nextWorldPos = FroxelPos2WorldPos(uint3(nextPos)).xyz;
        float stepLength = nextWorldPos.z - curWorldPos.z;

        transmittance *= exp(-extinction * stepLength);
        accumuLight += inScatter * scatterCoef * transmittance;
    }

    _AccumulationTex[pos] = float4(accumuLight, transmittance);


    //shadow /= _VolumeDepth;
    //_AccumulationTex[pos] = shadow.xxxx;
}
